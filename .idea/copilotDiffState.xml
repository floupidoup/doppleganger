<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/script.js">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/script.js" />
              <option name="originalContent" value="// ...existing code...&#10;&#10;function fakeSubmit(){&#10;  var raw = document.getElementById('name').value || '';&#10;  var name = raw.trim();&#10;  if(!name){&#10;    alert('Entrer un nom...');&#10;    return false;&#10;  }&#10;&#10;  // normaliser&#10;  var norm = name.toLowerCase();&#10;  // enregistrer en cookie pour usage ultérieur (en minuscule)&#10;  document.cookie = 'doppel=' + encodeURIComponent(norm) + ';path=/;max-age=31536000';&#10;&#10;  if(norm === 'whingu'){&#10;    // accès autorisé&#10;    alert('Accès autorisé. Approchez.');&#10;    setTimeout(function(){ window.location = 'secret.html'; }, 600);&#10;  } else {&#10;    // accès refusé&#10;    alert('Vous n\'êtes pas un doppelganger.');&#10;    // laisser la page en place pour éviter le contournement&#10;  }&#10;  return false;&#10;}&#10;&#10;// cheap flicker effect (conservé pour l'ambiance)&#10;setInterval(function(){&#10;  var el = document.querySelector('.title');&#10;  if(!el) return;&#10;  el.style.opacity = (Math.random()&gt;0.85)?'0.3':'1';&#10;},800);&#10;&#10;// noisy console&#10;console.log('DOPPLEGANGER INIT');&#10;console.warn('if you see this, do not stare in mirrors');&#10;&#10;// intentionally sloppy function to reveal secret link only for specific cookie&#10;function maybeReveal(){&#10;  var c = (document.cookie.match(/doppel=([^;]+)/)||[])[1];&#10;  if(c){&#10;    var n = decodeURIComponent(c);&#10;    if(n === 'whingu'){&#10;      var a = document.createElement('a');&#10;      a.href='secret.html'; a.style.color='#faa'; a.textContent='(un lien secret)';&#10;      a.style.display='block'; a.style.textAlign='center';&#10;      a.style.marginTop='8px';&#10;      document.body.appendChild(a);&#10;    }&#10;  }&#10;}&#10;setTimeout(maybeReveal,1200);&#10;&#10;&#10;// --- White noise (WebAudio) implementation ---&#10;// Creates a white-noise buffer and plays it in a loop through a gain node.&#10;(function(){&#10;  var AudioContext = window.AudioContext || window.webkitAudioContext;&#10;  if(!AudioContext) return; // no webaudio support&#10;&#10;  var ctx = null;&#10;  var noiseNode = null; // BufferSource&#10;  var noiseGain = null;&#10;  var isPlaying = false;&#10;&#10;  function createNoise(){&#10;    if(!ctx) ctx = new AudioContext();&#10;    // buffer: 2 seconds mono&#10;    var bufferSize = ctx.sampleRate * 2;&#10;    var buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);&#10;    var data = buffer.getChannelData(0);&#10;    for(var i=0;i&lt;bufferSize;i++){&#10;      data[i] = Math.random()*2 - 1;&#10;    }&#10;    var source = ctx.createBufferSource();&#10;    source.buffer = buffer;&#10;    source.loop = true;&#10;&#10;    var gain = ctx.createGain();&#10;    gain.gain.value = 0.25; // default volume (can be adjusted)&#10;&#10;    source.connect(gain).connect(ctx.destination);&#10;&#10;    return {source: source, gain: gain};&#10;  }&#10;&#10;  function startNoise(){&#10;    if(isPlaying) return;&#10;    var parts = createNoise();&#10;    noiseNode = parts.source;&#10;    noiseGain = parts.gain;&#10;    try{&#10;      if(ctx.state === 'suspended') ctx.resume();&#10;    }catch(e){}&#10;    // start the source only if context is running or the browser allows it&#10;    try{&#10;      noiseNode.start(0);&#10;      isPlaying = true;&#10;    }catch(err){&#10;      // if start throws (rare), clean up and mark not playing&#10;      try{ noiseNode.disconnect(); noiseGain.disconnect(); }catch(e){}&#10;      noiseNode = null; noiseGain = null; isPlaying = false;&#10;      throw err; // propagate so caller can fallback to gesture&#10;    }&#10;  }&#10;&#10;  // stopNoise retained but not exposed in UI&#10;  function stopNoise(){&#10;    if(!isPlaying) return;&#10;    try{ noiseNode.stop(0); }catch(e){}&#10;    try{ noiseNode.disconnect(); noiseGain.disconnect(); }catch(e){}&#10;    noiseNode = null; noiseGain = null; isPlaying = false;&#10;  }&#10;&#10;  // start-once handler: starts noise after a user gesture&#10;  function startOnce(){&#10;    if(!ctx){&#10;      try{ ctx = new AudioContext(); }catch(err){ console.warn('AudioContext failed', err); }&#10;    }&#10;    // resume context if needed then start noise&#10;    if(ctx &amp;&amp; ctx.state === 'suspended'){&#10;      ctx.resume().then(function(){&#10;        try{ startNoise(); }catch(e){ console.warn('startNoise failed after resume', e); }&#10;      }).catch(function(err){&#10;        console.warn('resume failed', err);&#10;      });&#10;    } else {&#10;      try{ startNoise(); }catch(e){ console.warn('startNoise failed on gesture', e); }&#10;    }&#10;&#10;    // remove listeners (we want it once)&#10;    document.removeEventListener('click', startOnce);&#10;    document.removeEventListener('keydown', startOnce);&#10;  }&#10;&#10;  // try to auto-start on load; if blocked (context suspended), listen for first gesture&#10;  document.addEventListener('DOMContentLoaded', function(){&#10;    try{&#10;      ctx = new AudioContext();&#10;    }catch(e){&#10;      console.warn('AudioContext creation failed', e);&#10;      return;&#10;    }&#10;&#10;    // attempt to start immediately&#10;    var attempted = false;&#10;    try{&#10;      // attempt to start; browsers may keep ctx.state === 'suspended' until gesture&#10;      startNoise();&#10;      attempted = true;&#10;    }catch(err){&#10;      // failed to start synchronously; we'll fallback to gesture&#10;      console.warn('Auto start failed or blocked, will wait for user gesture', err);&#10;    }&#10;&#10;    // If context is suspended or we didn't start, listen for user gesture&#10;    if(!attempted || (ctx &amp;&amp; ctx.state === 'suspended') || !isPlaying){&#10;      document.addEventListener('click', startOnce);&#10;      document.addEventListener('keydown', startOnce);&#10;      // also try a small timeout to resume if browser allows it shortly after load&#10;      setTimeout(function(){&#10;        if(ctx &amp;&amp; ctx.state === 'running' &amp;&amp; !isPlaying){&#10;          try{ startNoise(); }catch(e){ console.warn('startNoise after timeout failed', e); }&#10;        }&#10;      }, 800);&#10;    }&#10;&#10;    // visibility handling: suspend if page hidden, resume only if we were playing&#10;    document.addEventListener('visibilitychange', function(){&#10;      if(!ctx) return;&#10;      if(document.hidden){ if(ctx.state === 'running') ctx.suspend(); }&#10;      else { if(ctx.state === 'suspended' &amp;&amp; isPlaying) ctx.resume(); }&#10;    });&#10;  });&#10;&#10;})();&#10;" />
              <option name="updatedContent" value="// ...existing code...&#10;&#10;function fakeSubmit(){&#10;  var raw = document.getElementById('name').value || '';&#10;  var name = raw.trim();&#10;  if(!name){&#10;    alert('Entrer un nom...');&#10;    return false;&#10;  }&#10;&#10;  // normaliser&#10;  var norm = name.toLowerCase();&#10;  // enregistrer en cookie pour usage ultérieur (en minuscule)&#10;  document.cookie = 'doppel=' + encodeURIComponent(norm) + ';path=/;max-age=31536000';&#10;&#10;  if(norm === 'whingu'){&#10;    // accès autorisé&#10;    alert('Accès autorisé. Approchez.');&#10;    setTimeout(function(){ window.location = 'secret.html'; }, 600);&#10;  } else {&#10;    // accès refusé&#10;    alert('Vous n\'êtes pas un doppelganger.');&#10;    // laisser la page en place pour éviter le contournement&#10;  }&#10;  return false;&#10;}&#10;&#10;// cheap flicker effect (conservé pour l'ambiance)&#10;setInterval(function(){&#10;  var el = document.querySelector('.title');&#10;  if(!el) return;&#10;  el.style.opacity = (Math.random()&gt;0.85)?'0.3':'1';&#10;},800);&#10;&#10;// noisy console&#10;console.log('DOPPLEGANGER INIT');&#10;console.warn('if you see this, do not stare in mirrors');&#10;&#10;// intentionally sloppy function to reveal secret link only for specific cookie&#10;function maybeReveal(){&#10;  var c = (document.cookie.match(/doppel=([^;]+)/)||[])[1];&#10;  if(c){&#10;    var n = decodeURIComponent(c);&#10;    if(n === 'whingu'){&#10;      var a = document.createElement('a');&#10;      a.href='secret.html'; a.style.color='#faa'; a.textContent='(un lien secret)';&#10;      a.style.display='block'; a.style.textAlign='center';&#10;      a.style.marginTop='8px';&#10;      document.body.appendChild(a);&#10;    }&#10;  }&#10;}&#10;setTimeout(maybeReveal,1200);&#10;&#10;&#10;// --- White noise (WebAudio) implementation ---&#10;// Creates a white-noise buffer and plays it in a loop through a gain node.&#10;(function(){&#10;  var AudioContext = window.AudioContext || window.webkitAudioContext;&#10;  if(!AudioContext) return; // no webaudio support&#10;&#10;  var ctx = null;&#10;  var noiseNode = null; // BufferSource&#10;  var noiseGain = null;&#10;  var isPlaying = false;&#10;&#10;  function createNoise(){&#10;    if(!ctx) ctx = new AudioContext();&#10;    // buffer: 2 seconds mono&#10;    var bufferSize = ctx.sampleRate * 2;&#10;    var buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);&#10;    var data = buffer.getChannelData(0);&#10;    for(var i=0;i&lt;bufferSize;i++){&#10;      data[i] = Math.random()*2 - 1;&#10;    }&#10;    var source = ctx.createBufferSource();&#10;    source.buffer = buffer;&#10;    source.loop = true;&#10;&#10;    var gain = ctx.createGain();&#10;    gain.gain.value = 0.06; // volume réduit (ajusté pour être moins fort)&#10;&#10;    source.connect(gain).connect(ctx.destination);&#10;&#10;    return {source: source, gain: gain};&#10;  }&#10;&#10;  function startNoise(){&#10;    if(isPlaying) return;&#10;    var parts = createNoise();&#10;    noiseNode = parts.source;&#10;    noiseGain = parts.gain;&#10;    try{&#10;      if(ctx.state === 'suspended') ctx.resume();&#10;    }catch(e){}&#10;    // start the source only if context is running or the browser allows it&#10;    try{&#10;      noiseNode.start(0);&#10;      isPlaying = true;&#10;    }catch(err){&#10;      // if start throws (rare), clean up and mark not playing&#10;      try{ noiseNode.disconnect(); noiseGain.disconnect(); }catch(e){}&#10;      noiseNode = null; noiseGain = null; isPlaying = false;&#10;      throw err; // propagate so caller can fallback to gesture&#10;    }&#10;  }&#10;&#10;  // stopNoise retained but not exposed in UI&#10;  function stopNoise(){&#10;    if(!isPlaying) return;&#10;    try{ noiseNode.stop(0); }catch(e){}&#10;    try{ noiseNode.disconnect(); noiseGain.disconnect(); }catch(e){}&#10;    noiseNode = null; noiseGain = null; isPlaying = false;&#10;  }&#10;&#10;  // start-once handler: starts noise after a user gesture&#10;  function startOnce(){&#10;    if(!ctx){&#10;      try{ ctx = new AudioContext(); }catch(err){ console.warn('AudioContext failed', err); }&#10;    }&#10;    // resume context if needed then start noise&#10;    if(ctx &amp;&amp; ctx.state === 'suspended'){&#10;      ctx.resume().then(function(){&#10;        try{ startNoise(); }catch(e){ console.warn('startNoise failed after resume', e); }&#10;      }).catch(function(err){&#10;        console.warn('resume failed', err);&#10;      });&#10;    } else {&#10;      try{ startNoise(); }catch(e){ console.warn('startNoise failed on gesture', e); }&#10;    }&#10;&#10;    // remove listeners (we want it once)&#10;    document.removeEventListener('click', startOnce);&#10;    document.removeEventListener('keydown', startOnce);&#10;  }&#10;&#10;  // try to auto-start on load; if blocked (context suspended), listen for first gesture&#10;  document.addEventListener('DOMContentLoaded', function(){&#10;    try{&#10;      ctx = new AudioContext();&#10;    }catch(e){&#10;      console.warn('AudioContext creation failed', e);&#10;      return;&#10;    }&#10;&#10;    // attempt to start immediately&#10;    var attempted = false;&#10;    try{&#10;      // attempt to start; browsers may keep ctx.state === 'suspended' until gesture&#10;      startNoise();&#10;      attempted = true;&#10;    }catch(err){&#10;      // failed to start synchronously; we'll fallback to gesture&#10;      console.warn('Auto start failed or blocked, will wait for user gesture', err);&#10;    }&#10;&#10;    // If context is suspended or we didn't start, listen for user gesture&#10;    if(!attempted || (ctx &amp;&amp; ctx.state === 'suspended') || !isPlaying){&#10;      document.addEventListener('click', startOnce);&#10;      document.addEventListener('keydown', startOnce);&#10;      // also try a small timeout to resume if browser allows it shortly after load&#10;      setTimeout(function(){&#10;        if(ctx &amp;&amp; ctx.state === 'running' &amp;&amp; !isPlaying){&#10;          try{ startNoise(); }catch(e){ console.warn('startNoise after timeout failed', e); }&#10;        }&#10;      }, 800);&#10;    }&#10;&#10;    // visibility handling: suspend if page hidden, resume only if we were playing&#10;    document.addEventListener('visibilitychange', function(){&#10;      if(!ctx) return;&#10;      if(document.hidden){ if(ctx.state === 'running') ctx.suspend(); }&#10;      else { if(ctx.state === 'suspended' &amp;&amp; isPlaying) ctx.resume(); }&#10;    });&#10;  });&#10;&#10;})();" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>